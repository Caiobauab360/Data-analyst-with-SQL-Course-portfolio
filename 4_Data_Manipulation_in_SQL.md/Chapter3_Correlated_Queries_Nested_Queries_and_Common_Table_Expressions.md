# Correlated Queries, Nested Queries, and Common Table Expressions

**Chapter description:**

In this chapter, you will learn how to use nested and correlated subqueries to extract more complex data from a relational database. You will also learn about common table expressions and how to best construct queries using multiple common table expressions.

# Correlated subqueries

**Personal notes:**

Correlated subqueries are a special type of subquery that uses values from the outer query to generate the final results. The subquery is executed again each time a new row in the final dataset is returned, properly generating each new piece of information. Correlated subqueries are used for special types of calculations, such as advanced joining, filtering, and evaluating data in the database.

**A Simple Example*

In the previous chapter, you completed an exercise that answered the question "Which stages of the match, where the odds increase in each stage, tend to have a number of goals scored above average?" We did this using three simple subqueries in the SELECT, FROM, and WHERE statements. However, the same output can also be produced with a correlated subquery.

This query has only one difference: instead of including a filter for the season, the WHERE clause filters the data where the stage and match from the outer table were extracted from the subquery in FROM, is greater than the overall average generated in the WHERE subquery. The entire WHERE statement is essentially saying, "Return stages where the values in the subquery are greater than the average."
```sql
SELECT
	s.stage,
	ROUND(s.avg_goals,2) AS avg_goal,
	(SELECT AVG(home_goal + away_goal)
	FROM match
	WHERE season = '2012/2013') AS overall_avg
FROM
	(SELECT
		stage,
		AVG(home_goal + away_goal) AS avg_goals
	FROM match
	WHERE season = '2012/2013'
	GROUP BY stage) AS s
WHERE s.avg_goals > (SELECT AVG(home_goal + away_goal)
					FROM match AS m
					WHERE s.stage > m.stage);
```
**Simple vs. Correlated Subqueries*

Simple subqueries can be used in extracting, structuring, or filtering information and can run independently of the main query. On the other hand, a correlated subquery cannot run on its own because it depends on values from the main query. Also, a simple subquery is evaluated once throughout the statement. A correlated subquery is evaluated in loops—once for each row generated by the dataset. This means that adding correlated subqueries will make your query's performance slower, as your query is recalculating information repeatedly.

Another example, let's answer the question: "What is the average number of goals scored in each country across all seasons of games?" You simply join the match table to the country table on the id, extract the country name, take an average of the goals scored, and group the entire query by the country name, generating one row with an average value per country.
```sql
SELECT
	c.name AS country,
	AVG(m.home_goal + m.away_goal) AS avg_goals
FROM country AS c
LEFT JOIN match AS m
ON c.id = m.country_id
GROUP BY country;
```
A correlated subquery can be used here instead of a join:
```sql
SELECT
	c.name AS country,
	(SELECT 
		AVG(home_goal + away_goal)
	FROM match AS m
	WHERE m.country_id = c.id) AS avg_goals
FROM country AS c
GROUP BY country;
```

**Exercises:**

**Basic Correlated Subqueries**

Correlated subqueries are subqueries that reference one or more columns in the main query. Correlated subqueries depend on information in the main query to run, and thus, cannot be executed on their own.

Correlated subqueries are evaluated in SQL once per row of data retrieved -- a process that takes a lot more computing power and time than a simple subquery.

In this exercise, you will practice using correlated subqueries to examine matches with scores that are extreme outliers for each country -- above 3 times the average score!

**Instructions:**

- Select the country_id, date, home_goal, and away_goal columns in the main query.

- Complete the AVG value in the subquery.

- Complete the subquery column references, so that country_id is matched in the main and subquery.

```sql
SELECT 
    -- Select country ID, date, home, and away goals from match
    main.country_id,
    date,
    main.home_goal, 
    main.away_goal
FROM match AS main
WHERE 
    -- Filter the main query by the subquery
    (home_goal + away_goal) > 
        (SELECT AVG((sub.home_goal + sub.away_goal) * 3)
        FROM match AS sub
        -- Join the main query to the subquery in WHERE
        WHERE main.country_id = sub.country_id);
```

**Correlated subquery with multiple conditions**

Correlated subqueries are useful for matching data across multiple columns. In the previous exercise, you generated a list of matches with extremely high scores for each country. In this exercise, you're going to add an additional column for matching to answer the question -- what was the highest scoring match for each country, in each season?

*Note: this query may take a while to load.

**Instructions:**

- Select the country_id, date, home_goal, and away_goal columns in the main query.

- Complete the subquery: Select the matches with the highest number of total goals.

- Match the subquery to the main query using country_id and season.

- Fill in the correct logical operator so that total goals equals the max goals recorded in the subquery.

```sql
SELECT 
    -- Select country ID, date, home, and away goals from match
    main.country_id,
    main.date,
    main.home_goal,
    main.away_goal
FROM match AS main
WHERE 
    -- Filter for matches with the highest number of goals scored
    (home_goal + away_goal) = 
        (SELECT MAX(sub.home_goal + sub.away_goal)
        FROM match AS sub
        WHERE main.country_id = sub.country_id
            AND main.season = sub.season);
```

# Nested subqueries

**Personal notes:**

Nested subqueries are exactly what they sound like—subqueries nested within other subqueries.

**Inner Subquery*

For example, let's answer a similar question with an additional layer—"How does the total goals for each month differ from the monthly average of goals scored?" The logic for the inner subquery is: first, select the sum of goals scored in each month. The month is queried using the EXTRACT function.
```sql
SELECT
	EXTRACT(MONTH from date) AS month,
	SUM(home_goal + away_goal) AS goals
FROM match
GROUP BY month;
```

**Outer Subquery*

Next, you can place the second outer subquery to calculate an average of the values in the previous table, giving you the monthly average of goals scored. Since this result is a scalar subquery, you can now place it in the main query to calculate the final dataset.
```sql
SELECT AVG(goals)
FROM (SELECT
		EXTRACT(MONTH from date) AS month,
		AVG(home_goal + away_goal) AS goals
	FROM match
	GROUP BY month) AS s;
```

**Final Query*

Finally, you can place the entire nested subquery in the SELECT statement, giving you a scalar value to compare with the sum of goals scored in each month.
```sql
SELECT
	EXTRACT(MONTH from date) AS month,
	SUM(m.home_goal + m.away_goal) AS total_goals,
	SUM(m.home_goal + m.away_goal) -
		(SELECT AVG(goals)
		FROM (SELECT
				EXTRACT(MONTH from date) AS month,
				SUM(home_goal + away_goal) AS goals
				FROM match
				GROUP BY month) AS s) AS diff
FROM match as m
GROUP BY month;
```

**Correlated Nested Subqueries*

It's also important to note that nested queries can be correlated or not. It can also be a combination of both. Each of the correlated subqueries can reference information from an outer subquery or the main query.

For example, this query answers the question: What is the average number of goals scored by each country in a match in the 2011/2012 season? It is quite similar to the example from the previous chapter, except it requires an additional step. It has a second nested subquery within the SELECT statement, and the outer subquery has a correlated statement with the main query.
```sql
SELECT
	c.name AS country,
	(SELECT AVG(home_goal + away_goal)
	FROM match AS m
	WHERE m.country_id = c.id 
		AND id IN (
			SELECT id
			FROM match
			WHERE season = '2011/2012')) AS avg_goals
FROM country AS c
GROUP BY country;
```

**Exercises:**

**Nested simple subqueries**

Nested subqueries can be either simple or correlated.

Just like an unnested subquery, a nested subquery's components can be executed independently of the outer query, while a correlated subquery requires both the outer and inner subquery to run and produce results.

In this exercise, you will practice creating a nested subquery to examine the highest total number of goals in each season, overall, and during July across all seasons.

**Instructions:**

- Complete the main query to select the season and the max total goals in a match for each season. Name this max_goals.

- Complete the first simple subquery to select the max total goals in a match across all seasons. Name this overall_max_goals.

- Complete the nested subquery to select the maximum total goals in a match played in July across all seasons.

- Select the maximum total goals in the outer subquery. Name this entire subquery july_max_goals.

```sql
SELECT
    -- Select the season and max goals scored in a match
    season,
    MAX(home_goal + away_goal) AS max_goals,
    -- Select the overall max goals scored in a match
(SELECT MAX(home_goal + away_goal) FROM match) AS overall_max_goals,
-- Select the max number of goals scored in any match in July
(SELECT MAX(home_goal + away_goal) 
    FROM match
    WHERE id IN (
        SELECT id FROM match WHERE EXTRACT(MONTH FROM date) = 07)) AS july_max_goals
FROM match
GROUP BY season;
```

**Nest a subquery in FROM**

What's the average number of matches per season where a team scored 5 or more goals? How does this differ by country?

Let's use a nested, correlated subquery to perform this operation. In the real world, you will probably find that nesting multiple subqueries is a task you don't have to perform often. In some cases, however, you may find yourself struggling to properly group by the column you want, or to calculate information requiring multiple mathematical transformations (i.e., an AVG of a COUNT).

Nesting subqueries and performing your transformations one step at a time, adding it to a subquery, and then performing the next set of transformations is often the easiest way to yield accurate information about your data. Let's get to it!

**Instructions:**

- Generate a list of matches where at least one team scored 5 or more goals.

```sql
-- Select matches where a team scored 5+ goals
SELECT
    country_id,
    season,
    id
FROM match
WHERE home_goal >= 5 OR away_goal >= 5;
```

- Turn the query from the previous step into a subquery in the FROM statement.

- COUNT the match ids generated in the previous step, and group the query by country_id and season.

```sql
-- Count match ids
SELECT
    country_id,
    season,
    COUNT(id) AS matches
-- Set up and alias the subquery
FROM(
    SELECT
        country_id,
        season,
        id
    FROM match
    WHERE home_goal >= 5 OR away_goal >= 5)  AS subquery
-- Group by country_id and season
GROUP BY country_id, season;
```

- Finally, declare the same query from step 2 as a subquery in FROM with the alias outer_s.

- Left join it to the country table using the outer query's country_id column.

- Calculate an AVG of high scoring matches per country in the main query.

```sql
SELECT
    c.name AS country,
    -- Calculate the average matches per season
    AVG(outer_s.matches) AS avg_seasonal_high_scores
FROM country AS c
-- Left join outer_s to country
LEFT JOIN (
SELECT country_id, season,
        COUNT(id) AS matches
FROM (
    SELECT country_id, season, id
    FROM match
    WHERE home_goal >= 5 OR away_goal >= 5) AS inner_s
-- Close parentheses and alias the subquery
GROUP BY country_id, season) AS outer_s
ON c.id = outer_s.country_id
GROUP BY country;
```

# Common Table Expressions

**Personal notes:**

As seen, the queries we are constructing are quickly becoming long and complex. It can become difficult to clearly keep track of each piece of your query. We will cover a common method to improve the readability and accessibility of information in subqueries—the Common Table Expression (CTE).

Common Table Expressions, or CTEs, are a special type of subquery that is declared before your main query. Instead of including subqueries, say in the FROM statement, you name them using the WITH statement and then reference it by name later in the FROM statement as if it were any other table in your database.

```sql
WITH cte AS (
	SELECT col1, col2
	FROM table
)
SELECT
	AVG(col1) AS avg_col
FROM cte;
```

For example, let's rewrite a query from a previous exercise using a CTE. The following query uses a subquery, s, in the FROM statement to generate a list of country IDs and match IDs that meet certain criteria—specifically, we only wanted matches with 10 or more goals scored in total. This subquery is then joined to the countries table, and the count of matches in the subquery is counted in the main query.

To rewrite this query using a Common Table Expression to represent the subquery, simply remove the subquery from the FROM clause, place it at the beginning of the query, declare it using the WITH syntax, followed by a CTE name and AS.

```sql
WITH s AS (
	SELECT country_id, id
	FROM match
	WHERE (home_goal + away_goal) >= 10
)
```

Finally, complete the rest of the query just as you would if the CTE were an existing table in the database. You select the country name from the countries table, count the number of matches in the CTE "s", perform the join to the countries table, and then group the results by the country name alias.

```sql
WITH s AS (
	SELECT country_id, id
	FROM match
	WHERE (home_goal + away_goal) >= 10
)
SELECT
	c.name AS country,
	COUNT(s.id) AS matches
FROM country AS c
INNER JOIN s
ON c.id = s.country_id
GROUP BY country;
```

If you have multiple subqueries you want to turn into a Common Table Expression, you can simply list them one after the other, with a comma between each CTE, and without a comma after the last one. You can then retrieve the necessary information for the main query—just make sure to join properly to this second CTE as well.

```sql
WITH s1 AS (
	SELECT country_id, id
	FROM match
	WHERE (home_goal + away_goal) >= 10),
s2 AS (
	SELECT country_id, id
	FROM match
	WHERE (home_goal + away_goal) <= 1
)
SELECT
	c.name AS country,
	COUNT(s1.id) AS high_scores,
	COUNT(s2.id) AS low_scores
FROM country AS c
INNER JOIN s1
ON c.id = s1.country_id
INNER JOIN s2
ON c.id = s2.country_id
GROUP BY country;
```

**Why use CTEs?*

Common Table Expressions have several benefits over a subquery written within your main query. First, the CTE is executed only once and then stored in memory, usually leading to an improvement in the time required to execute your query. Second, CTEs are an excellent tool for organizing long and complex queries; you can declare as many CTEs as you need, one after the other. You can also reference information in CTEs declared earlier. For example, if you have 3 CTEs in a query, your third CTE can retrieve information from the first and second CTEs. Finally, a CTE can refer to itself in a special kind of table called a recursive CTE.

**Exercises:**

**Clean up with CTEs**

In chapter 2, you generated a list of countries and the number of matches in each country with more than 10 total goals. The query in that exercise utilized a subquery in the FROM statement in order to filter the matches before counting them in the main query. Below is the query you created:
```sql
SELECT
  c.name AS country,
  COUNT(sub.id) AS matches
FROM country AS c
INNER JOIN (
  SELECT country_id, id 
  FROM match
  WHERE (home_goal + away_goal) >= 10) AS sub
ON c.id = sub.country_id
GROUP BY country;
```
You can list one (or more) subqueries as common table expressions (CTEs) by declaring them ahead of your main query, which is an excellent tool for organizing information and placing it in a logical order.

In this exercise, let's rewrite a similar query using a CTE.

**Instructions:**

- Complete the syntax to declare your CTE.

- Select the country_id and match id from the match table in your CTE.

- Left join the CTE to the league table using country_id.

```sql
-- Set up your CTE
WITH match_list AS (
    SELECT 
        country_id, 
        id
    FROM match
    WHERE (home_goal + away_goal) >= 10)
-- Select league and count of matches from the CTE
SELECT
    l.name AS league,
    COUNT(match_list.id) AS matches
FROM league AS l
-- Join the CTE to the league table
LEFT JOIN match_list ON l.id = match_list.country_id
GROUP BY l.name;
```

**Organizing with CTEs**

Previously, you modified a query based on a statement you completed in chapter 2 using common table expressions.

This time, let's expand on the exercise by looking at details about matches with very high scores using CTEs. Just like a subquery in FROM, you can join tables inside a CTE.

**Instructions:**

- Declare your CTE, where you create a list of all matches with the league name.

- Select the league, date, home, and away goals from the CTE.

- Filter the main query for matches with 10 or more goals.

```sql
-- Set up your CTE
WITH match_list AS (
-- Select the league, date, home, and away goals
    SELECT 
        l.name AS league, 
        m.date, 
        m.home_goal, 
        m.away_goal,
    (m.home_goal + m.away_goal) AS total_goals
    FROM match AS m
    LEFT JOIN league as l ON m.country_id = l.id)
-- Select the league, date, home, and away goals from the CTE
SELECT league, date, home_goal, away_goal
FROM match_list
-- Filter by total goals
WHERE total_goals >= 10;
```

**CTEs with nested subqueries**

If you find yourself listing multiple subqueries in the FROM clause with nested statement, your query will likely become long, complex, and difficult to read.

Since many queries are written with the intention of being saved and re-run in the future, proper organization is key to a seamless workflow. Arranging subqueries as CTEs will save you time, space, and confusion in the long run!

**Instructions:**

- Declare a CTE that calculates the total goals from matches in August of the 2013/2014 season.

- Left join the CTE onto the league table using country_id from the match_list CTE.

- Filter the list on the inner subquery to only select matches in August of the 2013/2014 season.

```sql
-- Set up your CTE
WITH match_list AS (
    SELECT 
        country_id,
    (home_goal + away_goal) AS goals
    FROM match
    -- Create a list of match IDs to filter data in the CTE
    WHERE id IN (
    SELECT id
    FROM match
    WHERE season = '2013/2014' AND EXTRACT(MONTH FROM date) = 8))
-- Select the league name and average of goals in the CTE
SELECT 
    l.name,
    AVG(goals)
FROM league AS l
-- Join the CTE onto the league table
LEFT JOIN match_list ON l.id = match_list.country_id
GROUP BY l.name;
```

# Deciding on techniques to use

**Personal notes:**

**Joins*

Joins allow you to directly combine information from 2 or more tables and, on their own, are mainly limited to simple combinations and aggregations of tables already present in your database. Joins are a universally important skill when working with a database that has more than one table. It is fair to say that joins are necessary to understand each of the other techniques mentioned below.

**Correlated Subqueries*

A correlated subquery allows you to combine information between a subquery and a table or another subquery. It helps you simplify your syntax and overcome the limitations of a join, namely that you cannot join two separate columns in one table to a single column in another at a time. However, it's important to remember that correlated subqueries can take a long time to process and will decrease query performance. Correlated subqueries are great for combining data from different columns in one or more tables.

**Multiple/Nested Subqueries*

Multiple and nested subqueries are useful when your data requires multi-step transformations before it's in the format you need for your final query. Breaking down the steps of your query process allows for better accuracy and reproducibility in your work. Multiple subqueries are great for answering questions like "What is the average deal size closed by each sales representative in the last quarter," which would require several steps to transform and prepare before generating the final query.

**Common Table Expression (CTE)*

Common Table Expressions allow you to organize your subqueries sequentially by declaring them at the beginning of your query. As CTEs are processed one at a time before your main query, you can reference information from a CTE created earlier, serving as an alternative to nested subqueries. CTEs are excellent for comparing a large amount of disparate information. For example, to create a summary table examining the marketing, sales, growth, and performance of engineering teams and their key metrics in the last quarter. With CTEs, you can extract data about the performance of each team one after the other and combine them in a single query.

**So, Which Do I Use?*

Often, this really depends on the database you are using, the field you are working in, and the questions you are asking. In general, it is recommended that you practice each technique with your own databases to determine which allows you to use and reuse your queries effectively and generates clear and accurate results. Each technique has its strengths and use cases, and the choice depends on the specific requirements of your analysis.

**Exercises:**

**Get team names with a subquery**

Let's solve a problem we've encountered a few times in this course so far -- How do you get both the home and away team names into one final query result?

Out of the 4 techniques we just discussed, this can be performed using subqueries, correlated subqueries, and CTEs. Let's practice creating similar result sets using each of these 3 methods over the next 3 exercises, starting with subqueries in FROM.

**Instructions:**

- Create a query that left joins team to match in order to get the identity of the home team. This becomes the subquery in the next step.

```sql
SELECT 
    m.id, 
    t.team_long_name AS hometeam
-- Left join team to match
FROM match AS m
LEFT JOIN team as t
ON m.hometeam_id = team_api_id;
```

- Add a second subquery to the FROM statement to get the away team name, changing only the hometeam_id. Left join both subqueries to the match table on the id column.

```sql
SELECT
    m.date,
    -- Get the home and away team names
    home.hometeam,
    away.awayteam,
    m.home_goal,
    m.away_goal
FROM match AS m

-- Join the home subquery to the match table
LEFT JOIN (
SELECT match.id, team.team_long_name AS hometeam
FROM match
LEFT JOIN team
ON match.hometeam_id = team.team_api_id) AS home
ON home.id = m.id

-- Join the away subquery to the match table
LEFT JOIN (
SELECT match.id, team.team_long_name AS awayteam
FROM match
LEFT JOIN team
-- Get the away team ID in the subquery
ON match.awayteam_id = team.team_api_id) AS away
ON away.id = m.id;
```

**Get team names with correlated subqueries**

Let's solve the same problem using correlated subqueries -- How do you get both the home and away team names into one final query result?

This can easily be performed using correlated subqueries. But how might that impact the performance of your query? Complete the following steps and let's find out!

**Instructions:**

- Using a correlated subquery in the SELECT statement, match the team_api_id column from team to the hometeam_id from match.

```sql
SELECT
    m.date,
(SELECT team_long_name
    FROM team AS t
    -- Connect the team to the match table
    WHERE t.team_api_id = m.hometeam_id) AS hometeam
FROM match AS m;
```

- Create a second correlated subquery in SELECT, yielding the away team's name.

- Select the home and away goal columns from match in the main query.

```sql
SELECT
    m.date,
    (SELECT team_long_name
    FROM team AS t
    WHERE t.team_api_id = m.hometeam_id) AS hometeam,
    -- Connect the team to the match table
    (SELECT team_long_name
    FROM team AS t
    WHERE t.team_api_id = m.awayteam_id) AS awayteam,
    -- Select home and away goals
    m.home_goal,
    m.away_goal
FROM match AS m;
```

**Get team names with CTEs**

You've now explored two methods for answering the question, How do you get both the home and away team names into one final query result?

Let's explore the final method - common table expressions. Common table expressions are similar to the subquery method for generating results, mainly differing in syntax and the order in which information is processed.

**Instructions:**

- Select id from match and team_long_name from team. Join these two tables together on hometeam_id in match and team_api_id in team.

```sql
SELECT 
    -- Select match id and team long name
    m.id, 
    t.team_long_name AS hometeam
FROM match AS m
-- Join team to match using team_api_id and hometeam_id
LEFT JOIN team AS t 
ON m.hometeam_id = t.team_api_id;
```

- Declare the query from the previous step as a common table expression. SELECT everything from the CTE into the main query.

```sql
-- Declare the home CTE
WITH home AS (
    SELECT m.id, t.team_long_name AS hometeam
    FROM match AS m
    LEFT JOIN team AS t 
    ON m.hometeam_id = t.team_api_id)
-- Select everything from home
SELECT *
FROM home;
```

- Let's declare the second CTE, away. Join it to the first CTE on the id column.

- The date, home_goal, and away_goal columns have been added to the CTEs. SELECT them into the main query.

```sql
WITH home AS (
SELECT m.id, m.date, 
        t.team_long_name AS hometeam, m.home_goal
FROM match AS m
LEFT JOIN team AS t 
ON m.hometeam_id = t.team_api_id),
-- Declare and set up the away CTE
away AS (
SELECT m.id, m.date, 
        t.team_long_name AS awayteam, m.away_goal
FROM match AS m
LEFT JOIN team AS t 
ON m.awayteam_id = t.team_api_id)
-- Select date, home_goal, and away_goal
SELECT 
    home.date,
    home.hometeam,
    away.awayteam,
    home.home_goal,
    away.away_goal
-- Join away and home on the id column
FROM home
INNER JOIN away
ON home.id = away.id;
```

**Which technique to use?**

The previous three exercises demonstrated that, in many cases, you can use multiple techniques in SQL to answer the same question.

Based on what you learned, which of the following statements is false regarding differences in the use and performance of multiple/nested subqueries, correlated subqueries, and common table expressions?

        "Correlated subqueries can allow you to circumvent multiple, complex joins."